<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>IoT Predictive Maintenance Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/gaugeJS/dist/gauge.min.js"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js" type="text/javascript"></script>
      <style>
    /* Dark theme colors */
    :root {
      --dark-bg: #1a1a2e;
      --dark-secondary: #16213e;
      --dark-accent: #0f3460;
      --text-primary: #e6e6e6;
      --text-secondary: #b8b8b8;
      --accent-color: #4361ee;
      --danger-color: #e63946;
      --warning-color: #ff9f1c;
      --success-color: #2a9d8f;
      --card-bg: #242444;
      --border-color: #2a2a4a;
      --sidebar-width: 250px;
      --sidebar-collapsed-width: 70px;
    }

    body {
      background-color: var(--dark-bg);
      color: var(--text-primary);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
    }

    /* App container styles */
    .app-container {
      display: flex;
      min-height: 100vh;
    }

    /* Main content styles - updated to work with sidebar */
    .main-content {
      flex: 1;
      padding: 25px;
      background-color: var(--dark-bg);
      overflow-y: auto;
      transition: margin-left 0.3s;
      margin-left: var(--sidebar-width); /* Match sidebar width */
    }
    /* Dashboard header */
    .dashboard-h1 {
      color: var(--text-primary);
      font-size: 28px;
      margin-bottom: 25px;
      font-weight: 600;
      border-bottom: 2px solid var(--accent-color);
      padding-bottom: 10px;
      display: inline-block;
    }
    @media (max-width: 768px) {
      .main-content {
        margin-left: 0;
        padding-top: 60px; /* Add space for mobile header */
      }
    }

    /* Controls section */
    .controls {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
      background-color: var(--dark-secondary);
      padding: 15px;
      border-radius: 8px;
    }

    .controls button {
      padding: 10px 15px;
      background-color: var(--accent-color);
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
      font-size: 14px;
      white-space: nowrap;
    }

    .controls button i {
      font-size: 16px;
    }

    .controls button:hover {
      background-color: #3a56d4;
      transform: translateY(-2px);
    }

    

    /* Prediction section styles */
    .predictions-container {
      margin-top: 30px;
      padding: 20px;
      background-color: var(--dark-secondary);
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .predictions-container h2 {
      color: var(--text-primary);
      font-size: 22px;
      margin-bottom: 20px;
      font-weight: 600;
    }

    .predictions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-top: 15px;
    }

    .prediction-card {
      border-radius: 8px;
      padding: 20px;
      position: relative;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      background-color: var(--card-bg);
    }

    .prediction-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
    }

    .prediction-card.normal {
      border-left: 5px solid var(--success-color);
    }

    .prediction-card.warning {
      border-left: 5px solid var(--warning-color);
    }

    .prediction-card.danger {
      border-left: 5px solid var(--danger-color);
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 8px;
    }

    .status-indicator.normal {
      background-color: var(--success-color);
    }

    .status-indicator.warning {
      background-color: var(--warning-color);
    }

    .status-indicator.danger {
      background-color: var(--danger-color);
    }

    .prediction-title {
      font-weight: 600;
      font-size: 1.1em;
      margin-bottom: 12px;
      color: var(--text-primary);
    }

    .prediction-status {
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .prediction-probability {
      margin-bottom: 8px;
      color: var(--text-secondary);
    }

    .prediction-time {
      font-size: 0.9em;
      color: var(--text-secondary);
    }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      overflow-y: auto;
    }

    .modal-content {
      background-color: var(--dark-secondary);
      margin: 5% auto;
      padding: 25px;
      border-radius: 8px;
      width: 50%;
      max-width: 500px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-height: 90vh;
      overflow-y: auto;
      color: var(--text-primary);
      border: 1px solid var(--border-color);
    }

    .modal-content h2 {
      color: var(--text-primary);
      margin-bottom: 20px;
      font-weight: 600;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 10px;
    }

    .close {
      color: var(--text-secondary);
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    .close:hover {
      color: var(--text-primary);
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--text-primary);
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--dark-bg);
      color: var(--text-primary);
      font-size: 14px;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.3);
    }

    .form-actions {
      margin-top: 25px;
      text-align: right;
    }

    .btn {
      padding: 10px 18px;
      border-radius: 4px;
      cursor: pointer;
      border: none;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .btn-primary {
      background-color: var(--accent-color);
      color: white;
    }

    .btn-primary:hover {
      background-color: #3a56d4;
    }

    .btn-secondary {
      background-color: #4a4a6a;
      color: white;
      margin-right: 10px;
    }

    .btn-secondary:hover {
      background-color: #5a5a7a;
    }

    .btn-danger {
      background-color: var(--danger-color);
      color: white;
      margin-right: 10px;
    }

    .btn-danger:hover {
      background-color: #d62b39;
    }

    /* Gauge container styles */
    .gauge-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      /* Increased from 20px to 30px for more spacing */
      margin: 18px 20px;
      /* Added horizontal margin and increased top margin */
    }

    .gauge-wrapper {
      text-align: center;
      background-color: var(--dark-secondary);
      padding: 18px;
      /* Increased padding */
      border-radius: 12px;
      /* Increased border radius */
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }

    .gauge-wrapper:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
    }

    .gauge-title {
      font-weight: 600;
      margin-bottom: 15px;
      color: var(--text-primary);
      font-size: 16px;
    }

    .gauge-canvas {
      width: 100%;
      height: 150px;
      margin-bottom: 10px;
    }

    .gauge-value {
      font-size: 1.4em;
      margin: 10px 0;
      color: var(--text-primary);
      font-weight: 600;
    }

    /* Status indicators */
    .gauge-status {
      font-weight: 600;
      margin-top: 10px;
      padding: 5px 12px;
      border-radius: 20px;
      display: inline-block;
      font-size: 14px;
    }

    .gauge-status.normal {
      background-color: rgba(42, 157, 143, 0.2);
      color: var(--success-color);
      border: 1px solid var(--success-color);
    }

    .gauge-status.warning {
      background-color: rgba(255, 159, 28, 0.2);
      color: var(--warning-color);
      border: 1px solid var(--warning-color);
    }

    .gauge-status.danger {
      background-color: rgba(230, 57, 70, 0.2);
      color: var(--danger-color);
      border: 1px solid var(--danger-color);
    }

    /* Toggle switch for demo mode */
   /* Demo mode toggle styling - improved for mobile */
   .demo-mode-control {
      display: flex;
      align-items: center;
      margin-left: auto;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
      margin-left: 10px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #4a4a6a;
      transition: .4s;
      border-radius: 24px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked+.slider {
      background-color: var(--accent-color);
    }

    input:checked+.slider:before {
      transform: translateX(26px);
    }

    /* Responsive controls for small screens */
    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
        align-items: flex-start;
        padding: 12px;
      }
      
      .controls button {
        width: 100%;
        justify-content: center;
      }
      
      .demo-mode-control {
        width: 100%;
        justify-content: space-between;
        margin-left: 0;
        margin-top: 10px;
      }
    }
    .mqtt-status {
  margin-bottom: 20px;
  padding: 15px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from { transform: translateY(-20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.mqtt-status.connecting {
  background-color: var(--dark-accent);
  border-left: 5px solid var(--accent-color);
}

.mqtt-status.success {
  background-color: rgba(42, 157, 143, 0.2);
  border-left: 5px solid var(--success-color);
}

.mqtt-status.error {
  background-color: rgba(230, 57, 70, 0.2);
  border-left: 5px solid var(--danger-color);
}

.mqtt-status i {
  font-size: 20px;
  margin-right: 15px;
}

.mqtt-status.connecting i {
  color: var(--accent-color);
}

.mqtt-status.success i {
  color: var(--success-color);
}

.mqtt-status.error i {
  color: var(--danger-color);
}

.mqtt-status span {
  flex: 1;
}

.mqtt-reconnect-btn, .mqtt-close-btn {
  background-color: var(--dark-bg);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
  margin-left: 10px;
  transition: all 0.2s;
}

.mqtt-reconnect-btn:hover, .mqtt-close-btn:hover {
  background-color: var(--dark-accent);
  transform: translateY(-2px);
}

.mqtt-reconnect-btn {
  background-color: var(--accent-color);
  color: white;
}

.mqtt-reconnect-btn:hover {
  background-color: #3a56d4;
}
  </style>
</head>

<body>
  <div class="app-container">
    {% if 'user_id' in session %}
    {% with active_page='dashboard' %}
    {% include 'components/sidebar.html' %}
    {% endwith %}

    <!-- Main Content -->
    <div class="main-content" id="main-content">
      <h1 class="dashboard-h1">IoT Predictive Maintenance Dashboard</h1>
      <div class="controls">
        <button onclick="showAddGaugeModal()">
          <i class="fas fa-plus"></i> Add Gauge
        </button>
        <button onclick="showEditGaugeModal()">
          <i class="fas fa-edit"></i> Edit Gauge
        </button>
        <label for="demo-mode-toggle">Demo Data Mode</label>
        <label class="toggle-switch">
          <input type="checkbox" id="demo-mode-toggle" {% if config['read_demo_data'] %}checked{% endif %}
            onclick="toggleDemoMode()">
          <span class="slider"></span>
        </label>
      </div>

      <!-- Add the gauge container here -->
      <div class="gauge-container" id="gauge-container">
        <!-- Gauges will be dynamically added here -->
      </div>

      <!-- Add Prediction Section -->
      <div class="predictions-container">
        <h2>Asset Failure Predictions</h2>
        <div class="predictions-grid" id="predictions-grid">
          <!-- Using the prediction_card component with different parameters -->
          {% with asset_id='A1', title='Air Temperature & Humidity System', status='Normal Operation',
          status_class='normal', probability='0.00', last_updated='N/A' %}
          {% include 'components/prediction_card.html' %}
          {% endwith %}

          {% with asset_id='A2', title='Water Temperature System', status='Normal Operation',
          status_class='normal', probability='0.00', last_updated='N/A' %}
          {% include 'components/prediction_card.html' %}
          {% endwith %}

          {% with asset_id='A3', title='Ultrasonic Distance System', status='Normal Operation',
          status_class='normal', probability='0.00', last_updated='N/A' %}
          {% include 'components/prediction_card.html' %}
          {% endwith %}

          {% with asset_id='A4', title='Water Flow System', status='Normal Operation',
          status_class='normal', probability='0.00', last_updated='N/A' %}
          {% include 'components/prediction_card.html' %}
          {% endwith %}
        </div>
      </div>
    </div>
    {% else %}
    <script>
      window.location.href = "{{ url_for('auth.login') }}";
    </script>
    {% endif %}
  </div>

  <!-- Rest of your script and modal content -->

  <script>
    let dashboardConfig = {{ config | tojson | safe }};
    let demoData = {{ demo_data | tojson | safe }};
    let gauges = [];
    let currentDataIndex = 0;
    let mqttClient = null;

    document.addEventListener("DOMContentLoaded", function() {
    // Listen for sidebar collapse/expand events
    const sidebar = document.getElementById('sidebar');
    const mainContent = document.getElementById('main-content');
    
    // Create a MutationObserver to watch for class changes on the sidebar
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.attributeName === 'class') {
          if (sidebar.classList.contains('collapsed')) {
            mainContent.style.marginLeft = 'var(--sidebar-collapsed-width)';
          } else if (window.innerWidth > 768) {
            mainContent.style.marginLeft = 'var(--sidebar-width)';
          } else {
            mainContent.style.marginLeft = '0';
          }
        }
      });
    });
    
    // Start observing the sidebar for class changes
    if (sidebar) {
      observer.observe(sidebar, { attributes: true });
      
      // Initial adjustment
      if (window.innerWidth > 768) {
        if (sidebar.classList.contains('collapsed')) {
          mainContent.style.marginLeft = 'var(--sidebar-collapsed-width)';
        } else {
          mainContent.style.marginLeft = 'var(--sidebar-width)';
        }
      } else {
        mainContent.style.marginLeft = '0';
      }
    }
    
    // Handle window resize events
    window.addEventListener('resize', function() {
      if (!sidebar) return;
      
      if (window.innerWidth <= 768) {
        mainContent.style.marginLeft = '0';
      } else {
        if (sidebar.classList.contains('collapsed')) {
          mainContent.style.marginLeft = 'var(--sidebar-collapsed-width)';
        } else {
          mainContent.style.marginLeft = 'var(--sidebar-width)';
        }
      }
    });
  });


    // Function to initialize gauges
    function initializeGauges() {
      console.log("Initializing gauges with config:", dashboardConfig);
      const container = document.getElementById("gauge-container");
      container.innerHTML = '';
      gauges = [];

      // Debug output for demo data
      if (dashboardConfig.read_demo_data) {
        console.log("Demo mode is enabled");
        console.log("Demo data keys:", Object.keys(demoData));
        if (demoData.Timestamp) {
          console.log("Number of data points:", demoData.Timestamp.length);
        } else {
          console.warn("No Timestamp key in demo data");
        }
      }

      if (!dashboardConfig.gauges || dashboardConfig.gauges.length === 0) {
        console.warn("No gauge configurations found");
        return;
      }

      dashboardConfig.gauges.forEach(config => {
        const wrapper = document.createElement("div");
        wrapper.className = "gauge-wrapper";

        const title = document.createElement("div");
        title.className = "gauge-title";
        title.textContent = config.title;

        const canvas = document.createElement("canvas");
        canvas.className = "gauge-canvas";

        const valueDiv = document.createElement("div");
        valueDiv.className = "gauge-value";
        valueDiv.id = `value-${config.value_key.replace(/\./g, '-')}`;

        // Add status div for displaying normal/warning/danger state
        const statusDiv = document.createElement("div");
        statusDiv.className = "gauge-status normal";
        statusDiv.id = `status-${config.value_key.replace(/\./g, '-')}`;
        statusDiv.textContent = "Normal";

        wrapper.appendChild(title);
        wrapper.appendChild(canvas);
        wrapper.appendChild(valueDiv);
        wrapper.appendChild(statusDiv); // Add the status div to the wrapper

        container.appendChild(wrapper);

        // Set default values for thresholds if not defined
        const warningThreshold = config.warning_threshold || (config.max_val * 0.6);
        const dangerThreshold = config.danger_threshold || (config.max_val * 0.8);

        // Set default colors if not defined
        const normalColor = config.color || '#4CAF50';
        const warningColor = config.warning_color || '#FF9800';
        const dangerColor = config.danger_color || '#F44336';

        // Create color zones for the gauge
        const zones = [
          { strokeStyle: normalColor, min: config.min_val, max: warningThreshold },
          { strokeStyle: warningColor, min: warningThreshold, max: dangerThreshold },
          { strokeStyle: dangerColor, min: dangerThreshold, max: config.max_val }
        ];

        const gauge = new Gauge(canvas).setOptions({
          angle: -0.25,
          lineWidth: 0.2,
          radiusScale: 0.9,
          pointer: {
            length: 0.6,
            strokeWidth: 0.035,
            color: '#000000'
          },
          limitMax: true,
          limitMin: true,
          colorStart: normalColor,
          colorStop: normalColor,
          strokeColor: '#E0E0E0',
          generateGradient: true,
          highDpiSupport: true,
          staticZones: zones, // Use the color zones we defined
          staticLabels: {
            font: "12px sans-serif",
            labels: [config.min_val, warningThreshold, dangerThreshold, config.max_val],
            color: "#b8b8b8"
          },
        });

        gauge.maxValue = config.max_val;
        gauge.setMinValue(config.min_val);
        gauge.set(0);

        gauges.push({
          instance: gauge,
          valueElement: valueDiv,
          statusElement: statusDiv, // Add the status element to the gauge object
          config: config
        });
      });
    }
    function initializeMQTT() {
  if (!dashboardConfig.read_demo_data) {
    // Only connect if not in demo mode
    const broker = dashboardConfig.mqtt_broker || "broker.emqx.io";
    const port = dashboardConfig.mqtt_port || 8083; // WebSocket port (not 1883)
    const topic = dashboardConfig.mqtt_topic || "esp8266/sensorData";
    const clientId = "waterplant_dashboard_" + Math.random().toString(16).substr(2, 8);
    
    console.log(`Connecting to MQTT broker: ${broker}, port: ${port}, topic: ${topic}`);
    
    // Show connecting message
    showMqttStatus('connecting', `Connecting to MQTT broker: ${broker}...`);
    
    try {
      // Create client using the Paho MQTT library with WebSockets
      mqttClient = new Paho.MQTT.Client(broker, Number(port), clientId);
      
      // Set callback handlers
      mqttClient.onConnectionLost = function(responseObject) {
        console.log("Connection lost: " + responseObject.errorMessage);
        showMqttStatus('error', `MQTT connection lost: ${responseObject.errorMessage}`);
      };
      
      mqttClient.onMessageArrived = function(message) {
        try {
          console.log("Raw message:", message.payloadString);
          const data = JSON.parse(message.payloadString);
          console.log("Received MQTT data:", data);
          updateGaugesWithData(data);
          
          // Hide the status message when we receive data successfully
          hideMqttStatus();
        } catch (error) {
          console.error('Error parsing MQTT message:', error);
        }
      };
      
      // Connect the client with proper WebSocket configuration
      mqttClient.connect({
        onSuccess: function() {
          console.log('Connected to MQTT broker successfully');
          mqttClient.subscribe(topic);
          console.log(`Subscribed to topic: ${topic}`);
          showMqttStatus('success', 'Connected to MQTT broker successfully', true);
        },
        onFailure: function(message) {
          console.error("Connection failed: " + message.errorMessage);
          showMqttStatus('error', `Failed to connect to MQTT broker: ${message.errorMessage}`);
        },
        useSSL: location.protocol === 'https:',
        timeout: 3
      });
      
    } catch (error) {
      console.error('Error initializing MQTT client:', error);
      showMqttStatus('error', `Error initializing MQTT client: ${error.message}`);
    }
  }
}

// Function to show MQTT connection status
function showMqttStatus(type, message, autoHide = false) {
  // Remove any existing status message
  const existingStatus = document.getElementById('mqtt-status');
  if (existingStatus) {
    existingStatus.remove();
  }
  
  // Create status element
  const statusElement = document.createElement('div');
  statusElement.id = 'mqtt-status';
  statusElement.className = `mqtt-status ${type}`;
  
  // Add mobile-friendly positioning
  if (window.innerWidth <= 768) {
    statusElement.style.marginTop = 'var(--mobile-header-height)';
  }
  
  let icon = '';
  switch(type) {
    case 'connecting':
      icon = '<i class="fas fa-spinner fa-spin"></i>';
      break;
    case 'success':
      icon = '<i class="fas fa-check-circle"></i>';
      break;
    case 'error':
      icon = '<i class="fas fa-exclamation-circle"></i>';
      break;
  }
  
  statusElement.innerHTML = `
    ${icon}
    <span>${message}</span>
    ${type === 'error' ? '<button onclick="reconnectMqtt()" class="mqtt-reconnect-btn">Reconnect</button>' : ''}
    ${type === 'success' || type === 'connecting' ? '<button onclick="hideMqttStatus()" class="mqtt-close-btn">Dismiss</button>' : ''}
  `;
  
  // Add to the page
  document.querySelector('.main-content').insertBefore(statusElement, document.querySelector('.main-content').firstChild);
  
  // Auto-hide success messages after 5 seconds
  if (autoHide) {
    setTimeout(() => {
      hideMqttStatus();
    }, 5000);
  }
}
// Function to hide MQTT status message
function hideMqttStatus() {
  const statusElement = document.getElementById('mqtt-status');
  if (statusElement) {
    statusElement.remove();
  }
}

// Function to reconnect to MQTT broker
function reconnectMqtt() {
  if (mqttClient) {
    mqttClient.disconnect();
  }
  initializeMQTT();
}
    function updateGaugesWithData(data) {
      gauges.forEach(gauge => {
        const keys = gauge.config.value_key.split('.');
        let value = data;

        // Traverse nested object structure
        for (const key of keys) {
          if (value && value[key] !== undefined) {
            value = value[key];
          } else {
            value = undefined;
            break;
          }
        }

        if (value !== undefined && !isNaN(value)) {
          gauge.instance.set(value);
          gauge.valueElement.textContent = value.toFixed(1);

          // Update status based on thresholds
          const warningThreshold = gauge.config.warning_threshold || (gauge.config.max_val * 0.6);
          const dangerThreshold = gauge.config.danger_threshold || (gauge.config.max_val * 0.8);

          if (value >= dangerThreshold) {
            gauge.statusElement.textContent = "Danger";
            gauge.statusElement.className = "gauge-status danger";
          } else if (value >= warningThreshold) {
            gauge.statusElement.textContent = "Warning";
            gauge.statusElement.className = "gauge-status warning";
          } else {
            gauge.statusElement.textContent = "Normal";
            gauge.statusElement.className = "gauge-status normal";
          }
        }
      });
    }

    function updateGauges() {
      if (dashboardConfig.read_demo_data) {
        // Demo data handling
        console.log("Using demo data, current index:", currentDataIndex);

        if (!demoData || !demoData["Timestamp"] || demoData["Timestamp"].length === 0) {
          console.warn("Demo data is missing or empty");
          return;
        }

        gauges.forEach(gauge => {
          const dataKey = gauge.config.value_key;
          // For nested keys like "Ultrasonic.distance_cm"
          const keys = dataKey.split('.');
          let value;

          // If it's a nested key structure in the CSV
          if (keys.length > 1 && demoData[dataKey] === undefined) {
            // Try to find the column with the exact name
            if (demoData[dataKey] !== undefined) {
              value = demoData[dataKey][currentDataIndex];
            }
            // Try to find a column that ends with the last part of the key
            else {
              const lastKey = keys[keys.length - 1];
              for (const key in demoData) {
                if (key.endsWith(lastKey)) {
                  value = demoData[key][currentDataIndex];
                  break;
                }
              }
            }
          }
          // Direct key match
          else if (demoData[dataKey] && demoData[dataKey][currentDataIndex] !== undefined) {
            value = demoData[dataKey][currentDataIndex];
          } else {
            console.warn(`Key ${dataKey} not found in demo data or index out of bounds`);
          }

          if (value !== undefined) {
            gauge.instance.set(value);
            gauge.valueElement.textContent = value.toFixed(1);

            // Update status based on thresholds
            const warningThreshold = gauge.config.warning_threshold || (gauge.config.max_val * 0.6);
            const dangerThreshold = gauge.config.danger_threshold || (gauge.config.max_val * 0.8);

            if (value >= dangerThreshold) {
              gauge.statusElement.textContent = "Danger";
              gauge.statusElement.className = "gauge-status danger";
            } else if (value >= warningThreshold) {
              gauge.statusElement.textContent = "Warning";
              gauge.statusElement.className = "gauge-status warning";
            } else {
              gauge.statusElement.textContent = "Normal";
              gauge.statusElement.className = "gauge-status normal";
            }
          }
        });

        currentDataIndex = (currentDataIndex + 1) % demoData["Timestamp"].length;
      }

    }

    // Initialize everything when the document is loaded
    document.addEventListener("DOMContentLoaded", function () {
      console.log("DOM loaded, initializing dashboard");
      initializeGauges();

      // Initialize MQTT connection if not in demo mode
      initializeMQTT();

      // Set up update intervals only for demo mode
      if (dashboardConfig.read_demo_data) {
        const updateInterval = dashboardConfig.update_interval * 1000 || 2000;
        setInterval(updateGauges, updateInterval);
      }

      // Fetch predictions
      const predictionApiUrl = dashboardConfig.prediction_api_url || 'http://localhost:4000/api/predictions';
      console.log("Prediction API URL:", predictionApiUrl);

      function fetchPredictions() {
        console.log("Fetching predictions from:", predictionApiUrl);
        
        fetch(predictionApiUrl)
          .then(response => {
            console.log("Prediction API response status:", response.status);
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
          })
          .then(predictions => {
            console.log("Prediction API response data:", predictions);
            updatePredictionCards(predictions);
          })
          .catch(error => {
            console.error('Error fetching predictions:', error);
            document.querySelectorAll('.prediction-card').forEach(card => {
              const statusElement = card.querySelector('.prediction-status');
              if (statusElement) {
                statusElement.textContent = "API Error";
                statusElement.style.color = "#F44336";
              }
            });
          });
      }

      function updatePredictionCards(predictions) {
        for (const assetId in predictions) {
          const prediction = predictions[assetId];
          const card = document.getElementById(`prediction-${assetId}`);

          if (card) {
            const probability = prediction.failure_probability * 100;
            const isFailurePredicted = prediction.failure_predicted === 1;
            const status = isFailurePredicted ? 'Failure Predicted' : 'Normal Operation';
            const timestamp = prediction.timestamp ? new Date(prediction.timestamp).toLocaleString() : 'N/A';

            card.querySelector('.prediction-status').textContent = status;
            card.querySelector('.prediction-probability').textContent = `Failure Probability: ${probability.toFixed(2)}%`;
            card.querySelector('.prediction-time').textContent = `Last updated: ${timestamp}`;

            card.className = 'prediction-card';
            const indicator = card.querySelector('.status-indicator');

            if (isFailurePredicted) {
              card.classList.add('danger');
              indicator.className = 'status-indicator danger';
              
              // Check if notification should be sent for failure
              console.log("sending email")
              checkAndSendNotification(assetId, prediction, 'failure');
            } else if (probability > 20) {
              card.classList.add('warning');
              indicator.className = 'status-indicator warning';
              
              // Check if notification should be sent for warning
              checkAndSendNotification(assetId, prediction, 'warning');
            } else {
              card.classList.add('normal');
              indicator.className = 'status-indicator normal';
            }
          }
        }
      }

      // Function to check if notification should be sent and send it
      function checkAndSendNotification(assetId, prediction, status) {
        // Send notification request to server
        fetch('/send-notification', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            asset_id: assetId,
            prediction: prediction,
            status: status
          })
        })
        .then(response => response.json())
        .then(data => {
          if (data.sent) {
            console.log(`${status.charAt(0).toUpperCase() + status.slice(1)} notification sent for asset ${assetId}`);
          } else {
            console.log(`No ${status} notification sent for asset ${assetId}: ${data.reason}`);
          }
        })
        .catch(error => {
          console.error('Error sending notification:', error);
        });
      }

      // Fetch predictions initially and then every 5 seconds
      fetchPredictions();
      setInterval(fetchPredictions, 5000);
    });
    // Modal functions
    function showAddGaugeModal() {
      document.getElementById('addGaugeModal').style.display = 'block';
    }

    // Function to show edit gauge modal
    function showEditGaugeModal() {
      document.getElementById('editGaugeModal').style.display = 'block';

      // Add change event listener to populate form when a gauge is selected
      document.getElementById('gaugeSelect').onchange = function () {
        const selectedIndex = parseInt(this.value);
        if (!isNaN(selectedIndex) && selectedIndex >= 0) {
          const gauge = dashboardConfig.gauges[selectedIndex];
          document.getElementById('edit_title').value = gauge.title;
          document.getElementById('edit_value_key').value = gauge.value_key;
          document.getElementById('edit_min_val').value = gauge.min_val;
          document.getElementById('edit_max_val').value = gauge.max_val;
          document.getElementById('edit_color').value = gauge.color || '#4CAF50';

          // Set the warning and danger thresholds and colors
          document.getElementById('edit_warning_threshold').value = gauge.warning_threshold || 60;
          document.getElementById('edit_danger_threshold').value = gauge.danger_threshold || 80;
          document.getElementById('edit_warning_color').value = gauge.warning_color || '#FF9800';
          document.getElementById('edit_danger_color').value = gauge.danger_color || '#F44336';
        }
      };
    }

    function toggleDemoMode() {
      const isChecked = document.getElementById("demo-mode-toggle").checked;
      fetch("/toggle-data-mode", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ read_demo_data: isChecked })
      })
        .then(response => response.json())
        .then(data => {
          dashboardConfig.read_demo_data = data.read_demo_data;
          location.reload();
        })
        .catch(error => console.error("Error toggling demo mode:", error));
    }

  </script>
  <!-- Add Gauge Modal -->
  <div id="addGaugeModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="document.getElementById('addGaugeModal').style.display='none'">&times;</span>
      <h2>Add New Gauge</h2>
      <form id="addGaugeForm" action="{{ url_for('add_gauge') }}" method="POST">
        <div class="form-group">
          <label for="title">Title</label>
          <input type="text" id="title" name="title" required>
        </div>
        <div class="form-group">
          <label for="value_key">Value Key</label>
          <input type="text" id="value_key" name="value_key" required>
        </div>
        <div class="form-group">
          <label for="min_val">Minimum Value</label>
          <input type="number" id="min_val" name="min_val" value="0" required>
        </div>
        <div class="form-group">
          <label for="max_val">Maximum Value</label>
          <input type="number" id="max_val" name="max_val" value="100" required>
        </div>
        <div class="form-group">
          <label for="warning_threshold">Warning Threshold</label>
          <input type="number" id="warning_threshold" name="warning_threshold" value="60" required>
        </div>
        <div class="form-group">
          <label for="danger_threshold">Danger Threshold</label>
          <input type="number" id="danger_threshold" name="danger_threshold" value="80" required>
        </div>
        <div class="form-group">
          <label for="color">Normal Color</label>
          <input type="color" id="color" name="color" value="#4CAF50" required>
        </div>
        <div class="form-group">
          <label for="warning_color">Warning Color</label>
          <input type="color" id="warning_color" name="warning_color" value="#FF9800" required>
        </div>
        <div class="form-group">
          <label for="danger_color">Danger Color</label>
          <input type="color" id="danger_color" name="danger_color" value="#F44336" required>
        </div>
        <div class="form-actions">
          <button type="button" class="btn btn-secondary"
            onclick="document.getElementById('addGaugeModal').style.display='none'">Cancel</button>
          <button type="submit" class="btn btn-primary">Add Gauge</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Edit Gauge Modal -->
  <div id="editGaugeModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="document.getElementById('editGaugeModal').style.display='none'">&times;</span>
      <h2>Edit Gauge</h2>
      <form id="editGaugeForm" action="{{ url_for('edit_gauge') }}" method="POST">
        <div class="form-group">
          <label for="gaugeSelect">Select Gauge</label>
          <select id="gaugeSelect" name="gauge_index" required>
            <option value="">Select a gauge to edit</option>
            {% for i in range(config.gauges|length) %}
            <option value="{{ i }}">{{ config.gauges[i].title }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="form-group">
          <label for="edit_title">Title</label>
          <input type="text" id="edit_title" name="title" required>
        </div>
        <div class="form-group">
          <label for="edit_value_key">Value Key</label>
          <input type="text" id="edit_value_key" name="value_key" required>
        </div>
        <div class="form-group">
          <label for="edit_min_val">Minimum Value</label>
          <input type="number" id="edit_min_val" name="min_val" required>
        </div>
        <div class="form-group">
          <label for="edit_max_val">Maximum Value</label>
          <input type="number" id="edit_max_val" name="max_val" required>
        </div>
        <div class="form-group">
          <label for="edit_warning_threshold">Warning Threshold</label>
          <input type="number" id="edit_warning_threshold" name="warning_threshold" required>
        </div>
        <div class="form-group">
          <label for="edit_danger_threshold">Danger Threshold</label>
          <input type="number" id="edit_danger_threshold" name="danger_threshold" required>
        </div>
        <div class="form-group">
          <label for="edit_color">Normal Color</label>
          <input type="color" id="edit_color" name="color" required>
        </div>
        <div class="form-group">
          <label for="edit_warning_color">Warning Color</label>
          <input type="color" id="edit_warning_color" name="warning_color" required>
        </div>
        <div class="form-group">
          <label for="edit_danger_color">Danger Color</label>
          <input type="color" id="edit_danger_color" name="danger_color" required>
        </div>
        <div class="form-actions">
          <button type="button" class="btn btn-secondary"
            onclick="document.getElementById('editGaugeModal').style.display='none'">Cancel</button>
          <button type="button" class="btn btn-danger" onclick="deleteGauge()">Delete</button>
          <button type="submit" class="btn btn-primary">Save Changes</button>
        </div>
      </form>
    </div>
  </div>
</body>

</html>

<script>
  // Update the onchange event for the gauge select dropdown
  document.addEventListener("DOMContentLoaded", function () {
    // Add change event listener to populate form when a gauge is selected
    document.getElementById('gaugeSelect').onchange = function () {
      const selectedIndex = parseInt(this.value);
      if (!isNaN(selectedIndex) && selectedIndex >= 0) {
        const gauge = dashboardConfig.gauges[selectedIndex];
        document.getElementById('edit_title').value = gauge.title;
        document.getElementById('edit_value_key').value = gauge.value_key;
        document.getElementById('edit_min_val').value = gauge.min_val;
        document.getElementById('edit_max_val').value = gauge.max_val;
        document.getElementById('edit_color').value = gauge.color || '#4CAF50';

        // Set the warning and danger thresholds and colors
        document.getElementById('edit_warning_threshold').value = gauge.warning_threshold || 60;
        document.getElementById('edit_danger_threshold').value = gauge.danger_threshold || 80;
        document.getElementById('edit_warning_color').value = gauge.warning_color || '#FF9800';
        document.getElementById('edit_danger_color').value = gauge.danger_color || '#F44336';
      }
    };
  });
</script>

<script>
  // Add this after your existing modal functions

  // Set up form submission handlers
  document.addEventListener("DOMContentLoaded", function () {
    // Add gauge form submission
    document.getElementById('addGaugeForm').addEventListener('submit', function (e) {
      e.preventDefault();

      const formData = new FormData(this);

      // Convert FormData to URL-encoded string
      const urlEncodedData = new URLSearchParams(formData).toString();

      fetch('{{ url_for("add_gauge") }}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: urlEncodedData
      })
        .then(response => {
          if (response.redirected) {
            // If the server redirected, follow the redirect
            window.location.href = response.url;
            return;
          }

          if (!response.ok) {
            return response.text().then(text => {
              throw new Error('Error: ' + text);
            });
          }

          return response.json();
        })
        .then(data => {
          console.log('Gauge added successfully:', data);
          document.getElementById('addGaugeModal').style.display = 'none';
          // Reload the dashboard to show the new gauge
          window.location.reload();
        })
        .catch(error => {
          console.error('Error adding gauge:', error);
          alert('Error adding gauge. Please try again.');
        });
    });

    // Edit gauge form submission
    document.getElementById('editGaugeForm').addEventListener('submit', function (e) {
      e.preventDefault();

      const formData = new FormData(this);

      // Convert FormData to URL-encoded string
      const urlEncodedData = new URLSearchParams(formData).toString();

      fetch('{{ url_for("edit_gauge") }}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: urlEncodedData
      })
        .then(response => {
          if (response.redirected) {
            // If the server redirected, follow the redirect
            window.location.href = response.url;
            return;
          }

          if (!response.ok) {
            return response.text().then(text => {
              throw new Error('Error: ' + text);
            });
          }

          return response.json();
        })
        .then(data => {
          console.log('Gauge edited successfully:', data);
          document.getElementById('editGaugeModal').style.display = 'none';
          // Reload the dashboard to show the updated gauge
          window.location.reload();
        })
        .catch(error => {
          console.error('Error editing gauge:', error);
          alert('Error editing gauge. Please try again.');
        });
    });
  });

  // Add the deleteGauge function
  function deleteGauge() {
    const gaugeIndex = document.getElementById('gaugeSelect').value;
    if (!gaugeIndex) {
      alert('Please select a gauge to delete');
      return;
    }

    if (confirm('Are you sure you want to delete this gauge?')) {
      fetch('{{ url_for("delete_gauge") }}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: `gauge_index=${gaugeIndex}`
      })
        .then(response => {
          if (response.redirected) {
            window.location.href = response.url;
            return;
          }

          if (!response.ok) {
            return response.text().then(text => {
              throw new Error('Error: ' + text);
            });
          }

          return response.json();
        })
        .then(data => {
          console.log('Gauge deleted successfully:', data);
          document.getElementById('editGaugeModal').style.display = 'none';
          // Reload the dashboard to show the updated gauge list
          window.location.reload();
        })
        .catch(error => {
          console.error('Error deleting gauge:', error);
          alert('Error deleting gauge. Please try again.');
        });
    }
  }
</script>

<style>
  /* Add these styles to your existing CSS */
  .gauge-status {
    font-weight: bold;
    margin-top: 5px;
    padding: 3px 8px;
    border-radius: 4px;
    display: inline-block;
  }

  .gauge-status.normal {
    background-color: #e8f5e9;
    color: #4CAF50;
  }

  .gauge-status.warning {
    background-color: #fff3e0;
    color: #FF9800;
  }

  .gauge-status.danger {
    background-color: #ffebee;
    color: #F44336;
  }
</style>